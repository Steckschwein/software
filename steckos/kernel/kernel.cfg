SYMBOLS{
	#kernel start address
	__KERNEL_START__:   type=export, value=$c000;
    __APP_START__:      type=import;  # __APP_START__ will be imported from source code and is fixed after assembly phase (see appstart.inc) :/

}

MEMORY
{
    # $e0-$f1 are fixed locations - @see zeropage.inc
    ZP:         start=$f2,   size=$0e, type=rw, define=no;
    # 32 byte zp locations for library stuff
    ZP_LIB:     start=$c0,   size=$20, type=rw, define=no;
    ZPEXT:      start=$0280, size=$80, type=rw, define=no;
    LOADADDR:   start=__APP_START__-2, size = $0002;
    RAM:        start=$1000, size=kernel_start-__RAM_START__, type=rw, define=yes;
    CHARSET_ROM:    start=$8000, size=$4000, type=ro, fill=yes, define=yes;
    KERNEL_BSS: start=$df00, size=$ff, type=rw, define=no;
    KERNEL_RAM: start=__KERNEL_START__, size=$10000-kernel_start, type=rw, define=yes, fill=no, file=%O;
}

SEGMENTS
{
    ZEROPAGE: load=ZP, type=zp;
    ZEROPAGE_LIB: load = ZP_LIB, type=zp, optional=yes;
    DATA:     load=RAM, type = rw, define = yes, align = $100;
    LOADADDR:  load = LOADADDR, type = ro, optional=yes;

    CODE:     load=KERNEL_RAM, type=rw;


    CHARSET: load=CHARSET_ROM, type=ro, define=yes, optional=no;

    # NOTE: we use type=rw here and NOT type=bss, cause we need an memory image of the kernel with fixed size
    BSS:      load=KERNEL_BSS, type=bss, define = yes, optional=no;
    JUMPTABLE:load=KERNEL_RAM, type=ro, start=$ff90, optional=yes;
    VECTORS:  load=KERNEL_RAM, type=ro, start=$fff8, optional=yes;
}
